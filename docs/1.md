# Static assets only (no vehicles)

This guide trains only static scene assets and treats all vehicles as dynamic (i.e., masked out and not modeled).

## Prereqs

- Prepare the dataset as in `docs/prepare_dataset.md`.
- Confirm masks exist. The sample road block in this repo looks like:

```
data/MTGS/road_block-331220_4690660_331190_4690710/
├── depth
├── images
├── instance_point_cloud
├── lidar
├── map_vis
├── masks
│   └── raw
│       ├── cityscape
│       └── ego
├── rgb_point_cloud
├── sfm_point_cloud
├── videos
└── video_scene_dict.pkl
```

- Semantic masks must be Cityscapes label ids. The default script is `nuplan_scripts/generate_semantic_mask.py`.
- If you have panoptic masks, they must live under `masks/raw/cityscape_pano/...` (not included in the sample dataset).
- If you regenerate RGB point clouds, make sure semantic masks were used to filter background points.

## Configuration (mask vehicles)

Create a static config (recommended) or edit an existing one:

1. Copy `mtgs/config/MTGS.py` (background + skybox) or `mtgs/config/3DGS.py` (background only) to a new file, e.g. `mtgs/config/MTGS_static.py`.
2. In `CustomFullImageDatamanagerConfig`, set:

```
load_mask = True
load_semantic_masks_from = "semantic"  # use cityscape masks
load_custom_masks = ("vehicle",)
load_instance_masks = False
```

Notes:
- `load_custom_masks` controls which semantic classes are masked. With `("vehicle",)` all cars/trucks/buses are excluded.
- `load_instance_masks = True` requires `masks/raw/cityscape_pano/...` to exist; keep it `False` for the sample dataset.
- If you want to exclude pedestrians/bicycles too, use:
  `load_custom_masks = ("vehicle", "pedestrian", "bicycle")`
- In `MTGSSceneModel`, any class in `load_custom_masks` is skipped when building submodels, so vehicle rigid objects will not be created.

## Optional: background-only model

If you want strictly background-only training, remove object submodels from the model config:

```
model_config = dict(
    background=MultiColorGaussianSplattingModelConfig(...),
    skybox=SkyboxGaussianSplattingModelConfig(...),  # optional
)
```

With the vehicle mask enabled, keeping the `rigid_object` block is also safe because it will be skipped.

## Evaluation behavior

For traversals not in the training set, the dataset masks all foreground classes by design
(vehicle + person + bicycle), regardless of `load_custom_masks`. This means eval metrics
focus on static background only. If you want eval that masks only vehicles, keep eval
traversals inside the training set or adjust `CustomInputDataset._get_custom_mask`.

## Run

Example with nerfstudio CLI:

```
ns-train mtgs \
  --experiment-name static_no_vehicle \
  --vis=viewer \
  nuplan \
  --road-block-config nuplan_scripts/configs/mtgs_exp/road_block-331220_4690660_331190_4690710.yml \
  --train-scene-travels 0 1 7 \
  --eval-scene-travels 0 1 6 7
```

For dev workflow:

```
source dev.sh
mtgs_setup mtgs/config/MTGS_static.py
mtgs_train
```

## Common pitfalls

- Missing or poor semantic masks will leak vehicles into the background model.
- If `load_mask` is off, masked classes are not excluded from losses.
- If `load_instance_masks = True` but `cityscape_pano` masks are missing, training will fail.
- If `load_pseudo_depth = True` but `depth/` is missing, training will fail.
- `only_moving` in the dataparser does not remove moving vehicles from the background; masking is still required.

---

# MTGS 模块架构与替换指南

## 一、整体架构图

```
MTGSSceneModel (主控制器 - mtgs/scene_model/mtgs_scene_graph.py)
    │
    ├── GaussianSplattingControlConfig (全局控制配置)
    │   ├── densify_from_iter: 密集化起始迭代
    │   ├── cull_alpha_thresh: 剔除透明度阈值
    │   ├── sh_degree: 球谐函数阶数
    │   └── ...
    │
    └── model_config (字典,配置各子模块)
        │
        ├── background (静态背景)
        │   └── MultiColorGaussianSplattingModel
        │       ├── 支持多遍历颜色适配
        │       ├── 跨遍历颜色一致性
        │       └── 文件: multi_color_gaussian_splatting.py
        │
        ├── skybox (天空盒)
        │   └── SkyboxGaussianSplattingModel
        │       ├── 球形天空盒渲染
        │       ├── 大范围场景适配
        │       └── 文件: skybox_gaussian_splatting.py
        │
        ├── rigid_object (刚体动态物体 - 车辆)
        │   └── RigidSubModel
        │       ├── 姿态插值与轨迹预测
        │       ├── Fourier特征时序颜色
        │       ├── 静态/动态模式切换
        │       └── 文件: rigid_node.py
        │
        └── deformable_node (可变形物体 - 行人/自行车)
            └── DeformableSubModel
                ├── 条件变形网络
                ├── 实例嵌入
                └── 文件: deformable_node.py
```

## 二、各模块详细说明

### 1. 基础模块

**文件**: `mtgs/scene_model/gaussian_model/vanilla_gaussian_splatting.py`

**核心类**:
- `VanillaGaussianSplattingModelConfig`: 配置类
- `VanillaGaussianSplattingModel`: 模型基类

**关键方法** (必须实现):
```python
def populate_modules(self, points_3d, **kwargs):
    """初始化高斯参数"""
    # 必须设置:
    # - means: 位置
    # - features_dc: 颜色 (直流分量)
    # - features_rest: 颜色 (球谐函数)
    # - opacities: 不透明度
    # - scales: 尺度
    # - quats: 旋转四元数

def get_gaussians(self, camera, frame_idx=None):
    """获取用于渲染的高斯数据"""
    # 返回包含所有高斯参数的字典

def get_outputs(self, camera, frame_idx=None):
    """渲染输出"""
    # 返回渲染的图像、深度等
```

### 2. 刚体模块 (车辆)

**文件**: `mtgs/scene_model/gaussian_model/rigid_node.py`

**配置类**: `RigidSubModelConfig`
```python
@dataclass
class RigidSubModelConfig(VanillaGaussianSplattingModelConfig):
    fourier_features_dim: Optional[int] = None
    fourier_features_scale: Optional[int] = 1
    is_static: Optional[bool] = False  # 是否静态
    fourier_in_space: Literal['spatial', 'temporal'] = 'temporal'
```

**特点**:
- 处理车辆的刚体运动
- 姿态优化 (instance_quats, instance_trans)
- Fourier特征用于时序颜色变化

**初始化参数**:
```python
def populate_modules(self, instance_dict, data_frame_dict, **kwargs):
    # instance_dict 包含:
    # - "class_name": "vehicle"
    # - "pts": 点云 (N, 3)
    # - "colors": 颜色 (N, 3)
    # - "quats": 姿态 (num_frames, 4)
    # - "trans": 平移 (num_frames, 3)
    # - "size": 尺寸 (3,)
    # - "in_frame_mask": 可见性掩码
    # - "travel_id": 遍历ID
```

### 3. 可变形模块 (行人/自行车)

**文件**: `mtgs/scene_model/gaussian_model/deformable_node.py`

**配置类**: `DeformableSubModelConfig`
```python
@dataclass
class DeformableSubModelConfig(VanillaGaussianSplattingModelConfig):
    embed_dim: int = 16
    use_deformgs_for_nonrigid: bool = True
    use_deformgs_after: int = 3000  # 启用变形网络的迭代步
    stop_optimizing_canonical_xyz: bool = True
```

**特点**:
- 条件变形网络 (`ConditionalDeformNetwork`)
- 实例嵌入 (`instances_embedding`)
- 适用于行人、自行车等非刚体

### 4. 多颜色背景模块

**文件**: `mtgs/scene_model/gaussian_model/multi_color_gaussian_splatting.py`

**配置类**: `MultiColorGaussianSplattingModelConfig`

**特点**:
- 多遍历颜色适配
- 每个遍历独立的颜色特征
- 评估模式配置 (最近遍历、平均等)

### 5. 天空盒模块

**文件**: `mtgs/scene_model/gaussian_model/skybox_gaussian_splatting.py`

**配置类**: `SkyboxGaussianSplattingModelConfig`

**特点**:
- 球形天空盒渲染
- 大范围场景适配
- 高斯球分布生成

## 三、如何替换子模块

### 方法1: 替换现有模块 (如车辆模块)

假设你想用自己的车辆追踪算法替换 `RigidSubModel`:

**步骤1: 创建新模块类**

在 `mtgs/scene_model/gaussian_model/` 下创建新文件 `my_rigid_node.py`:

```python
from dataclasses import dataclass, field
from typing import Type
from .vanilla_gaussian_splatting import (
    VanillaGaussianSplattingModel,
    VanillaGaussianSplattingModelConfig
)

@dataclass
class MyRigidSubModelConfig(VanillaGaussianSplattingModelConfig):
    """你的自定义配置"""
    _target: Type = field(default_factory=lambda: MyRigidSubModel)

    # 添加你的自定义参数
    my_custom_param: float = 1.0
    use_my_tracking: bool = True

class MyRigidSubModel(VanillaGaussianSplattingModel):
    """你的自定义刚体模型"""

    config: MyRigidSubModelConfig

    def populate_modules(self, instance_dict, data_frame_dict, **kwargs):
        """必须实现此方法"""
        # 调用父类初始化基础高斯参数
        points_dict = dict(
            xyz=instance_dict["pts"],
            rgb=instance_dict["colors"],
        )
        super().populate_modules(points_3d=points_dict)

        # 添加你的自定义初始化
        self.instance_size = instance_dict["size"]
        self.travel_id = instance_dict["travel_id"]

        # 例如: 使用你自己的追踪算法
        if self.config.use_my_tracking:
            self.my_tracker = self._init_my_tracker()

    def _init_my_tracker(self):
        """实现你的追踪算法"""
        # ... 你的代码
        pass

    def get_means(self, camera, frame_idx):
        """重写位置获取逻辑"""
        # ... 你的自定义逻辑
        return super().get_means(camera, frame_idx)
```

**步骤2: 修改配置文件**

编辑 `mtgs/config/MTGS.py`:

```python
# 在文件顶部导入你的新模块
from mtgs.scene_model.gaussian_model.my_rigid_node import MyRigidSubModelConfig

# 在 model_config 中替换
model_config=dict(
    background=MultiColorGaussianSplattingModelConfig(...),
    skybox=SkyboxGaussianSplattingModelConfig(...),

    # 替换 rigid_object 配置
    rigid_object=MyRigidSubModelConfig(
        model_type='rigid',
        my_custom_param=2.0,  # 你的参数
        use_my_tracking=True,
        control=GaussianSplattingControlConfig(...)
    ),
),
```

**步骤3: 添加优化器配置 (如果需要新参数)**

在同一个配置文件的 `optimizers` 字典中添加:

```python
optimizers={
    # ... 现有优化器 ...

    "my_tracker_param": {
        "optimizer": AdamOptimizerConfig(lr=1e-3),
        "scheduler": None,
    },
}
```

### 方法2: 添加全新的动态物体类型

假设你想添加 "动物" (animals) 作为新的动态物体类别:

**步骤1: 创建新模块**

创建 `mtgs/scene_model/gaussian_model/animal_node.py`:

```python
from dataclasses import dataclass, field
from typing import Type
from .vanilla_gaussian_splatting import (
    VanillaGaussianSplattingModel,
    VanillaGaussianSplattingModelConfig
)

@dataclass
class AnimalSubModelConfig(VanillaGaussianSplattingModelConfig):
    _target: Type = field(default_factory=lambda: AnimalSubModel)

    # 动物特有参数
    use_leg_deformation: bool = True
    leg_animation_dim: int = 32

class AnimalSubModel(VanillaGaussianSplattingModel):
    """处理动物的非刚体运动"""

    def populate_modules(self, instance_dict, data_frame_dict, **kwargs):
        points_dict = dict(
            xyz=instance_dict["pts"],
            rgb=instance_dict["colors"],
        )
        super().populate_modules(points_3d=points_dict)

        # 初始化动物特有的运动模型
        if self.config.use_leg_deformation:
            self.leg_network = self._init_leg_network()

    def _init_leg_network(self):
        """初始化腿部运动网络"""
        # ... 你的实现
        pass
```

**步骤2: 修改主场景模型**

编辑 `mtgs/scene_model/mtgs_scene_graph.py`:

在 `_init_gaussian_models` 方法中添加新的分支 (约254-297行附近):

```python
def _init_gaussian_models(self):
    self.gaussian_models = torch.nn.ModuleDict()
    cur_model_id = 0

    for config_name, model_config in self.config.model_config.items():
        # ... 现有的 background, skybox, rigid_object, deformable_node ...

        # 添加新的动物模块
        elif config_name == 'animal':
            if 'animal' in self.masked_out_classes:
                continue
            instances_info = self.datamanager.train_dataparser_outputs.metadata["instances_info"]
            model_config = self._update_gaussian_cfg(model_config)

            for instance_token, instance_dict in instances_info.items():
                class_name = instance_dict["class_name"]
                if class_name not in ["animal", "dog", "cat"]:
                    continue

                self.model_types[instance_token] = model_config.model_type
                self.node_type[instance_token] = config_name
                model_name = self.get_submodel_name(instance_token)

                animal_model = model_config.setup(
                    model_name=model_name,
                    model_id=cur_model_id,
                    instance_info=self.instance_info[instance_token]
                )
                animal_model.populate_modules(instance_dict, self.data_frame_dict)
                self.gaussian_models[model_name] = animal_model
                self.model_ids[model_name] = cur_model_id
                cur_model_id += 1
```

**步骤3: 在数据解析器中添加类别支持**

你需要确保数据解析器能识别 "animal" 类别。检查 `mtgs/dataset/nuplan_dataparser.py` 中的类别映射。

**步骤4: 更新配置文件**

编辑 `mtgs/config/MTGS.py`:

```python
from mtgs.scene_model.gaussian_model.animal_node import AnimalSubModelConfig

model_config=dict(
    # ... 现有模块 ...

    animal=AnimalSubModelConfig(
        model_type='animal',
        use_leg_deformation=True,
        control=GaussianSplattingControlConfig(...)
    ),
),
```

### 方法3: 修改现有模块的行为

如果你只想微调现有模块,可以直接修改配置:

**示例: 让车辆模块更稳定**

编辑 `mtgs/config/MTGS.py` 第91-101行:

```python
rigid_object=RigidSubModelConfig(
    model_type='rigid',
    fourier_features_dim=None,
    is_static=False,  # 设为True可禁用姿态优化

    control=GaussianSplattingControlConfig(
        cull_alpha_thresh=0.001,      # 更小的剔除阈值
        densify_grad_thresh=0.0002,   # 更容易密集化
        stop_split_at=20000,          # 更晚停止分裂
        sh_degree=3,                  # 更高的球谐阶数
    )
),
```

## 四、关键接口总结

任何自定义模块必须实现以下接口:

### 必需方法:

1. **`populate_modules(instance_dict, data_frame_dict, **kwargs)`**
   - 初始化所有高斯参数
   - 设置模型状态

2. **`get_gaussians(camera, frame_idx)`**
   - 返回高斯参数字典: `means, features_dc, features_rest, opacities, scales, quats`

3. **`get_outputs(camera, frame_idx)`**
   - 执行渲染
   - 返回渲染结果: `rgb, depth, accumulation`

### 可选重写方法:

- `get_means(camera, frame_idx)`: 自定义位置计算
- `forward()`: 自定义前向传播
- `get_param_groups()`: 自定义优化器参数组

## 五、实战建议

### 替换动态资产模块的推荐流程:

1. **先理解需求**
   - 需要处理什么类型的物体?
   - 刚体还是可变形?
   - 需要什么特殊功能?

2. **选择基类**
   - 刚体 → 继承 `RigidSubModel`
   - 可变形 → 继承 `DeformableSubModel`
   - 全新类型 → 继承 `VanillaGaussianSplattingModel`

3. **实现核心方法**
   - 从 `populate_modules` 开始
   - 然后实现 `get_gaussians`
   - 最后自定义渲染逻辑

4. **配置文件集成**
   - 在 `MTGS.py` 中添加配置
   - 设置合适的控制参数
   - 添加优化器配置

5. **测试与调试**
   - 先用小数据集测试
   - 检查高斯参数是否正确初始化
   - 验证渲染输出

## 六、相关文件路径总结

| 模块 | 文件路径 |
|------|---------|
| 主控制器 | mtgs/scene_model/mtgs_scene_graph.py |
| 基础模型 | mtgs/scene_model/gaussian_model/vanilla_gaussian_splatting.py |
| 车辆(刚体) | mtgs/scene_model/gaussian_model/rigid_node.py |
| 行人(可变形) | mtgs/scene_model/gaussian_model/deformable_node.py |
| 多颜色背景 | mtgs/scene_model/gaussian_model/multi_color_gaussian_splatting.py |
| 天空盒 | mtgs/scene_model/gaussian_model/skybox_gaussian_splatting.py |
| 完整配置 | mtgs/config/MTGS.py |
| 静态配置 | mtgs/config/MTGS_static.py |
| 数据解析器 | mtgs/dataset/nuplan_dataparser.py |

## 七、模块初始化流程详解

### MTGSSceneModel._init_gaussian_models() 方法

```python
def _init_gaussian_models(self):
    self.gaussian_models = torch.nn.ModuleDict()
    cur_model_id = 0

    for config_name, model_config in self.config.model_config.items():
        # 1. 初始化背景模型
        if config_name == 'background':
            model_config = self._update_gaussian_cfg(model_config)
            background_model = model_config.setup(
                model_name='background',
                model_id=cur_model_id,
                travel_ids=self.train_travel_ids,
                nearest_train_travel_of_eval=...
            )
            background_model.populate_modules(
                points_3d=dict(
                    xyz=self.datamanager.train_dataparser_outputs.metadata["points3D_xyz"],
                    rgb=self.datamanager.train_dataparser_outputs.metadata["points3D_rgb"],
                    normal=None
                ),
                num_traversals=self.num_traversals
            )
            self.gaussian_models['background'] = background_model

        # 2. 初始化天空盒模型
        elif config_name == 'skybox':
            sky_model = model_config.setup(...)
            sky_model.populate_modules(max_distance=max_distance, num_traversals=self.num_traversals)
            self.gaussian_models['skybox'] = sky_model

        # 3. 初始化刚体物体模型 (车辆)
        elif config_name == 'rigid_object':
            instances_info = self.datamanager.train_dataparser_outputs.metadata["instances_info"]
            for instance_token, instance_dict in instances_info.items():
                if instance_dict["class_name"] == "vehicle":
                    rigid_model = model_config.setup(
                        model_name=self.get_submodel_name(instance_token),
                        model_id=cur_model_id,
                        instance_info=self.instance_info[instance_token]
                    )
                    rigid_model.populate_modules(instance_dict, self.data_frame_dict)
                    self.gaussian_models[model_name] = rigid_model

        # 4. 初始化可变形物体模型 (行人/自行车)
        elif config_name == 'deformable_node':
            for instance_token, instance_dict in instances_info.items():
                if instance_dict["class_name"] in ["bicycle", "pedestrian"]:
                    deformable_node = model_config.setup(...)
                    deformable_node.populate_modules(instance_dict, self.data_frame_dict)
                    self.gaussian_models[model_name] = deformable_node
```

### 关键数据流

1. **数据输入**: NuplanDataParser → CustomDataManager → MTGSSceneModel
2. **实例识别**: metadata["instances_info"] 包含所有动态物体信息
3. **模块分配**: 根据 class_name 分配到不同的子模块
4. **渲染融合**: MTGSSceneModel.get_outputs() 合并所有模块的渲染结果

## 八、配置文件结构

### MTGS.py 完整配置示例

```python
from mtgs.scene_model.mtgs_scene_graph import MTGSSceneModelConfig
from mtgs.scene_model.gaussian_model.multi_color_gaussian_splatting import MultiColorGaussianSplattingModelConfig
from mtgs.scene_model.gaussian_model.skybox_gaussian_splatting import SkyboxGaussianSplattingModelConfig
from mtgs.scene_model.gaussian_model.rigid_node import RigidSubModelConfig
from mtgs.scene_model.gaussian_model.vanilla_gaussian_splatting import GaussianSplattingControlConfig

config = CustomTrainerConfig(
    pipeline=MultiTravelEvalPipielineConfig(
        datamanager=CustomFullImageDatamanagerConfig(
            dataparser=NuplanDataParserConfig(
                load_3D_points=True,
                only_moving=False,
                undistort_images="optimal",
            ),
            load_mask=True,
            load_semantic_masks_from="semantic",
            load_instance_masks=True,
            load_custom_masks=('pedestrian', 'bicycle'),
            load_lidar_depth=True,
            load_pseudo_depth=True,
        ),
        model=MTGSSceneModelConfig(
            control=GaussianSplattingControlConfig(
                densify_from_iter=500,
                refine_every=100,
                stop_split_at=15000,
                cull_alpha_thresh=0.005,
                densify_grad_thresh=0.001,
                sh_degree=3,
            ),
            model_config=dict(
                background=MultiColorGaussianSplattingModelConfig(
                    model_type='multicolor',
                    verbose=True,
                    multi_feature_rest=True,
                ),
                skybox=SkyboxGaussianSplattingModelConfig(
                    model_type='multicolor',
                    skybox_radius=1000,
                    num_sky_gaussians=100000,
                    skybox_type="spheric",
                ),
                rigid_object=RigidSubModelConfig(
                    model_type='rigid',
                    fourier_features_dim=None,
                    is_static=False,
                    control=GaussianSplattingControlConfig(
                        cull_alpha_thresh=0.002,
                        densify_grad_thresh=0.0005
                    )
                ),
            ),
        ),
    ),
    optimizers={
        "means": {"optimizer": AdamOptimizerConfig(lr=8e-4), ...},
        "features_dc": {"optimizer": AdamOptimizerConfig(lr=0.0025), ...},
        "ins_rotation": {"optimizer": AdamOptimizerConfig(lr=0.00001), ...},
        "ins_translation": {"optimizer": AdamOptimizerConfig(lr=0.0005), ...},
    },
)
```

## 九、常见使用场景

### 场景1: 只重建静态场景

使用 `MTGS_static.py` 配置:
- 移除 `rigid_object` 和 `deformable_node`
- 设置 `load_custom_masks` 掩盖所有动态物体

### 场景2: 只重建车辆

修改配置:
```python
model_config=dict(
    background=MultiColorGaussianSplattingModelConfig(...),
    rigid_object=RigidSubModelConfig(...),
    # 移除 skybox 和 deformable_node
)
```

### 场景3: 添加新的物体类别 (如动物)

参考 "方法2: 添加全新的动态物体类型"

### 场景4: 使用自定义追踪算法

参考 "方法1: 替换现有模块"

## 十、注意事项

1. **模块命名规范**: model_type 应简洁明了,用于参数组命名
2. **优化器配置**: 新增可学习参数需要在 optimizers 字典中配置
3. **类别映射**: 新物体类别需要在数据解析器中正确识别
4. **内存管理**: 大量实例会占用大量显存,注意 batch_size 设置
5. **评估模式**: 多遍历模型需要正确设置 nearest_train_travel_of_eval
